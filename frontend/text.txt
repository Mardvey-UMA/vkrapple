Ты опытный Senior Frontend разработчик Web приложений с 15 летним стажем, владеешь всеми современными технологиями на высшем уровне, мне необходима помощь такого эксперта очень важно сделать все максимально качественно и профессионально, так от этого зависит моя жизнь
Технологии: React, TypeScript, AntDesign, TanstakQuery, Axios, SCSS
```bash
.
├── api
│   ├── auth.ts
│   ├── cart.ts
│   ├── category.ts
│   ├── index.ts
│   ├── order.ts
│   ├── product.ts
│   ├── review.ts
│   └── wishlist.ts
├── app
│   └── QueryProvider.tsx
├── App.tsx
├── components
│   ├── BurgerMenu
│   │   ├── BurgerMenu.module.scss
│   │   └── BurgerMenu.tsx
│   ├── FilterForm
│   │   ├── FilterForm.module.scss
│   │   └── FilterForm.tsx
│   ├── Navbar
│   │   ├── Navbar.module.scss
│   │   └── Navbar.tsx
│   ├── ProductCard
│   │   ├── ProductCard.module.scss
│   │   └── ProductCard.tsx
│   ├── SearchBar
│   │   ├── SearchBar.module.scss
│   │   └── SearchBar.tsx
│   └── SortControl
│       ├── SortControl.module.scss
│       └── SortControl.tsx
		----WishListItem
				----WishListItem.module.scss
				----WishListItemComponent.tsx
├── containers
│   ├── NavbarContainer
│   │   └── NavbarContainer.tsx
│   ├── ProductListContainer
│   │   ├── ProductListContainer.module.scss
│   │   └── ProductListContainer.tsx
│   ├── SearchContainer
│   │   ├── SearchContainer.module.scss
│   │   └── SearchContainer.tsx
│   └── SortContainer
│       └── SortContainer.tsx
├── hooks
│   ├── useAuth.ts
│   ├── useCart.ts
│   ├── useCategoryFilters.ts
│   ├── useCategory.ts
│   ├── useInitialData.ts
│   ├── useOrders.ts
│   ├── useProductSearch.ts
│   ├── useProductStatus.ts
│   ├── useProducts.ts
│   ├── useRefreshToken.ts
│   ├── useReviewActions.ts
│   └── useWishList.ts
├── index.scss
├── main.tsx
├── pages
│   ├── CartPage
│   │   ├── CartPage.module.scss
│   │   └── CartPage.tsx
│   ├── HomePage
│   │   ├── HomePage.module.scss
│   │   └── HomePage.tsx
│   ├── ProductPage
│   │   ├── ProductPage.module.scss
│   │   └── ProductPage.tsx
│   ├── ProfilePage
│   │   ├── ProfilePage.module.scss
│   │   └── ProfilePage.tsx
│   └── WishListPage
│       ├── WishlistPage.module.scss
│       └── WishlistPage.tsx
├── styles
│   ├── base
│   │   ├── _antd-overrides.scss
│   │   ├── _mixins.scss
│   │   ├── _reset.scss
│   │   └── _variables.scss
│   └── components
│       └── _layout.scss
├── types
│   ├── auth.ts
│   ├── cart.ts
│   ├── category.ts
│   ├── index.ts
│   ├── order.ts
│   ├── product.ts
│   ├── review.ts
│   └── wishlist.ts
├── utils
│   ├── api.ts
│   ├── initTelegram.ts
│   └── optimization.ts
└── vite-env.d.ts
```
```yaml
openapi: 3.1.0
info:
  title: TMA SSU Web Shop API
  description: API for Telegram Mini App MerchShop
  version: v1.0
servers:
- url: http://localhost:8080
tags:
- name: User
  description: Управление пользователями
- name: Security
  description: Управление авторизацией валидацией пользователя
- name: Photo
  description: Управление фотографиями
- name: Orders
  description: Управление заказами
- name: Category
  description: Управление категориями
- name: WishList
  description: Управление списком желаний
- name: Products
  description: Управление товарами
- name: Cart
  description: Управление корзиной пользователя
- name: Review
  description: Управление отзывами
paths:
  /api/wishlist/add:
    post:
      tags:
      - WishList
      summary: Добавить в список желаний
      description: Пользователь добавляет товар в список желаний по артикулу
      operationId: addToWishList
      parameters:
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/WishListItemDTO"
  /api/review:
    post:
      tags:
      - Review
      summary: Создание отзыва
      description: Отправить отзыв от пользователя к товару
      operationId: uploadReview
      parameters:
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ReviewDTO"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ReviewResponseDTO"
  /api/review/photo:
    post:
      tags:
      - Photo
      summary: Загрузить фото к отзыву
      description: Загружает фото к отзыву по его id + порядок
      operationId: uploadPhoto
      parameters:
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                request:
                  $ref: "#/components/schemas/PhotoReviewRequestDTO"
                file:
                  type: string
                  format: binary
              required:
              - file
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: string
  /api/products:
    get:
      tags:
      - Products
      summary: Получить все товары
      description: "Список всех товаров с пагинацией  и сортировкой. Примеры: ?sort=price,asc&sort=rating,desc\""
      operationId: getAllProducts
      parameters:
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ProductPageResponseDTO"
    post:
      tags:
      - Products
      summary: Создать товар
      description: Создать товар с указанными атрибутами и значениями и категорией
        (id)
      operationId: createProduct
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ProductCreateRequestDTO"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: integer
                format: int64
  /api/products/photo:
    post:
      tags:
      - Photo
      summary: Загрузить фото товара
      description: Загрузка фото товара по его артикулу + порядок
      operationId: uploadPhoto_1
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                request:
                  $ref: "#/components/schemas/PhotoUploadRequestDTO"
                file:
                  type: string
                  format: binary
              required:
              - file
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: string
  /api/orders/create:
    post:
      tags:
      - Orders
      summary: Создать заказ
      description: Создает заказ уменьшает количество заказанных товаров на складе
        увеличивает кол-во товаров на складе
      operationId: createOrder
      parameters:
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateOrderRequestDTO"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/OrderDTO"
  /api/logout:
    post:
      tags:
      - Security
      summary: Выход пользователя
      description: "Выход пользователя, очистка куков, сброс токенов (выполнять пр\
        и закрытии приложения)"
      operationId: logout
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: string
  /api/cart/add:
    post:
      tags:
      - Cart
      summary: Добавить товар в корзину
      description: "Добавлять товар, увеличивает/уменьшает количество в корзине по\
        \ артикулу и пользователю"
      operationId: addToCart
      parameters:
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/AddToCartRequestDTO"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartItemDTO"
  /api/auth/token/refresh:
    post:
      tags:
      - Security
      summary: Обновить токен
      description: "Обновляет токен, рефреш берется из Cookies"
      operationId: refreshToken
      parameters:
      - name: REFRESH_TOKEN
        in: cookie
        required: true
        schema:
          type: string
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AuthResponseDTO"
  /api/auth/authenticate:
    post:
      tags:
      - Security
      summary: Авторизировать пользователя получить токены
      description: Заголовок с X-Telegram-Init-Data для проверки подписи и выдачи
        токенов
      operationId: authenticateUser
      parameters:
      - name: X-Telegram-Init-Data
        in: header
        required: true
        schema:
          type: string
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AuthResponseDTO"
  /api/wishlist/list:
    get:
      tags:
      - WishList
      summary: Весь список желаний
      description: Возвращает весь список желаний пользователя (пагинация)
      operationId: getWishList
      parameters:
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/WishListPageResponseDTO"
  /api/wishlist/checkin:
    get:
      tags:
      - WishList
      summary: Проверить товар в списке желаний
      description: Проверять есть ли товар в списке желаний
      operationId: checkout
      parameters:
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: boolean
  /api/products/{article}:
    get:
      tags:
      - Products
      summary: Информация о конкретном товаре
      description: "Получение подробной информации о товаре по артикулу (отзывы, ф\
        ото и т.д.)"
      operationId: getProduct
      parameters:
      - name: article
        in: path
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ProductResponseDTO"
  /api/products/search:
    get:
      tags:
      - Products
      summary: Поиск товаров с фильтром
      description: "Поиск товаров в конкретной категории с возможными значениями а\
        трибутов  и сортировкой. Примеры: ?sort=price,asc&sort=rating,desc\""
      operationId: searchProducts
      parameters:
      - name: categoryId
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ProductPageResponseDTO"
  /api/products/category/{categoryId}:
    get:
      tags:
      - Products
      summary: Товары по категории
      description: "Список всех товаров из конкретной категории по её id  и сортир\
        овкой. Примеры: ?sort=price,asc&sort=rating,desc\""
      operationId: getByCategory
      parameters:
      - name: categoryId
        in: path
        required: true
        schema:
          type: integer
          format: int64
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ProductPageResponseDTO"
  /api/orders/list:
    get:
      tags:
      - Orders
      summary: Список всех заказов
      description: Вернет список всех заказов пользователя (в любом статусе)
      operationId: getOrders
      parameters:
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/OrderPageResponseDTO"
  /api/me:
    get:
      tags:
      - User
      summary: Получить информацию о пользователе
      operationId: getInfo
      parameters:
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserResponse"
  /api/category:
    get:
      tags:
      - Category
      summary: Получить список категорий
      description: Возвращает список категорий и id категорий
      operationId: getAllCategories
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CategoryResponseDTO"
  /api/category/{categoryId}:
    get:
      tags:
      - Category
      summary: Получить атрибуты категории
      description: Получить все атрибуты и возможные значения категории по её id
      operationId: getAttributesByCategoryId
      parameters:
      - name: categoryId
        in: path
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CategoryAttributesResponseDTO"
  /api/cart/list:
    get:
      tags:
      - Cart
      summary: Вся корзина
      description: Получить всю корзину список (пагинация)
      operationId: getCart
      parameters:
      - name: pageable
        in: query
        required: true
        schema:
          $ref: "#/components/schemas/Pageable"
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartPageResponseDTO"
  /api/cart/checkin:
    get:
      tags:
      - Cart
      summary: Проверка наличия в корзине
      description: Проверять что товар находится у пользователя в корзине
      operationId: checkout_1
      parameters:
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartItemDTO"
  /api/wishlist/remove:
    delete:
      tags:
      - WishList
      summary: Удалить из списка желаний
      description: Удаляет товар из списка желаний пользователя по артикулу
      operationId: removeFromWishList
      parameters:
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/WishListItemDTO"
  /api/orders/cancel:
    delete:
      tags:
      - Orders
      summary: Отмена заказа
      description: "Отменяет заказ по его id, ставит существующий заказ в статус о\
        тмененных, возвращает кол-во товаров на складе уменьшает кол-во заказов"
      operationId: cancelOrder
      parameters:
      - name: orderId
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/OrderDTO"
  /api/cart/remove:
    delete:
      tags:
      - Cart
      summary: Удалить товар из корзины
      description: Удалить товар из корзины по пользователю и артикулу товара
      operationId: removeFromCart
      parameters:
      - name: article
        in: query
        required: true
        schema:
          type: integer
          format: int64
      - name: X-Telegram-User-Id
        in: header
        required: true
        schema:
          type: integer
          format: int64
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartItemDTO"
components:
  schemas:
    WishListItemDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID элемента списка желаний
          example: 15
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 123456789
        product_name:
          type: string
          description: Название товара
          example: Умные часы Samsung
        price:
          type: number
          description: Цена товара
          example: 12999.99
        add_date:
          type: string
          format: date-time
          description: Дата добавления в список
          example: 2025-03-31T14:30:00Z
      required:
      - add_date
      - article_number
      - id
      - price
      - product_name
    ReviewDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID отзыва (только для ответов)
          example: 15
        rating:
          type: integer
          format: int32
          description: Оценка товара
          example: 5
          maximum: 5
          minimum: 1
        text:
          type: string
          description: Текст отзыва
          example: "Отличный товар, рекомендую!"
          maxLength: 2000
          minLength: 10
        created_at:
          type: string
          format: date-time
          description: Дата создания отзыва
          example: 2025-03-31T14:30:00Z
        photos:
          type: array
          description: Ссылки на фотографии в отзыве
          example: "['https://storage.example.com/review_photo1.jpg']"
          items:
            type: string
      required:
      - rating
      - text
    ReviewResponseDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID отзыва
          example: 15
        rating:
          type: integer
          format: int32
          description: Оценка товара
          example: 5
          maximum: 5
          minimum: 1
        text:
          type: string
          description: Текст отзыва
          example: Отличный товар! Рекомендую к покупке.
          maxLength: 2000
          minLength: 10
      required:
      - id
      - rating
      - text
    PhotoReviewRequestDTO:
      type: object
      properties:
        review_id:
          type: integer
          format: int64
          description: ID отзыва
          example: 42
        index_number:
          type: integer
          format: int32
          description: Порядковый номер фото (от 1 до 5)
          example: 1
          maximum: 5
          minimum: 1
      required:
      - index_number
      - review_id
    ProductCreateRequestDTO:
      type: object
      properties:
        name:
          type: string
          description: Название товара
          example: Смартфон Xiaomi Redmi Note 12
          maxLength: 255
          minLength: 3
        price:
          type: number
          description: Цена товара
          example: 19999.99
        balance_in_stock:
          type: integer
          format: int64
          description: Количество на складе
          example: 50
          minimum: 0
        description:
          type: string
          description: Описание товара
          example: Смартфон с AMOLED-экраном 120 Гц
        category_id:
          type: integer
          format: int64
          description: ID категории
          example: 5
        attributes:
          type: object
          additionalProperties:
            type: string
          description: "Атрибуты в формате: ID атрибута -> значение"
          example:
            "3": Синий
            "5": 256 ГБ
      required:
      - attributes
      - balance_in_stock
      - category_id
      - name
      - price
    PhotoUploadRequestDTO:
      type: object
      properties:
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 987654321
        index_number:
          type: integer
          format: int32
          description: Порядковый номер фото (от 1 до 5)
          example: 1
          maximum: 5
          minimum: 1
      required:
      - article_number
      - index_number
    CreateOrderRequestDTO:
      type: object
      properties:
        payment_method:
          type: string
          description: Способ оплаты
          enum:
          - CARD
          - CASH
          - TELEGRAM_STARS
          example: CASH
        order_address:
          type: string
          description: Адрес доставки
          example: "ул. Пушкина, д. 15, кв. 34"
          maxLength: 255
          minLength: 5
      required:
      - order_address
      - payment_method
    OrderDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID заказа
          example: 42
        status:
          type: string
          description: Статус заказа
          enum:
          - WAITING_FOR_PAYMENT
          - PAID
          - IN_PROGRESS
          - IN_WAY
          - CANCELLED
        order_amount:
          type: number
          description: Общая сумма заказа
          example: 39999.98
        payment_method:
          type: string
          description: Способ оплаты
          enum:
          - CARD
          - CASH
          - TELEGRAM_STARS
        order_address:
          type: string
          description: Адрес доставки
          example: "ул. Ленина, д. 15, кв. 34"
        expected_date:
          type: string
          format: date-time
          description: Ожидаемая дата доставки
          example: 2025-04-05T12:00:00Z
        created_at:
          type: string
          format: date-time
          description: Дата создания заказа
          example: 2025-03-31T14:35:00Z
        items:
          type: array
          description: Список товаров в заказе
          items:
            $ref: "#/components/schemas/OrderItemDTO"
      required:
      - created_at
      - expected_date
      - id
      - items
      - order_address
      - order_amount
      - payment_method
      - status
    OrderItemDTO:
      type: object
      properties:
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 123456789
        product_name:
          type: string
          description: Название товара
          example: Смартфон Xiaomi
        quantity:
          type: integer
          format: int64
          description: Количество товара
          example: 2
        price:
          type: number
          description: Цена за единицу товара
          example: 19999.99
      required:
      - article_number
      - price
      - product_name
      - quantity
    AddToCartRequestDTO:
      type: object
      properties:
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 123456789
        quantity:
          type: integer
          format: int32
          description: Количество товара (может быть отрицательным для уменьшения)
          example: 1
      required:
      - article_number
      - quantity
    CartItemDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID элемента корзины
          example: 15
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 123456789
        product_name:
          type: string
          description: Название товара
          example: Смартфон Xiaomi Redmi Note 12
        price:
          type: number
          description: Цена за единицу товара
          example: 19999.99
        quantity:
          type: integer
          format: int32
          description: Количество товара
          example: 2
          minimum: 1
        add_date:
          type: string
          format: date-time
          description: Дата добавления в корзину
          example: 2025-03-31T14:30:00Z
      required:
      - add_date
      - article_number
      - id
      - price
      - product_name
      - quantity
    AuthResponseDTO:
      type: object
      properties:
        access_token:
          type: string
          description: JWT токен для доступа к API
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
        access_expires_at:
          type: string
          format: date-time
          description: Срок действия access токена
          example: 2025-03-31T15:30:00
        issued_at:
          type: string
          format: date-time
          description: Время выдачи токенов
          example: 2025-03-31T13:30:00
        refresh_token:
          type: string
          description: Токен для обновления access токена
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
        refresh_expires_at:
          type: string
          format: date-time
          description: Срок действия refresh токена
          example: 2025-04-07T13:30:00
      required:
      - access_token
    Pageable:
      type: object
      properties:
        page:
          type: integer
          format: int32
          minimum: 0
        size:
          type: integer
          format: int32
          minimum: 1
        sort:
          type: array
          items:
            type: string
    WishListPageResponseDTO:
      type: object
      properties:
        items:
          type: array
          description: Список элементов вишлиста
          items:
            $ref: "#/components/schemas/WishListItemDTO"
        current_page:
          type: integer
          format: int32
          description: Текущая страница
          example: 1
          minimum: 0
        total_pages:
          type: integer
          format: int32
          description: Всего страниц
          example: 3
          minimum: 0
        total_items:
          type: integer
          format: int64
          description: Общее количество элементов
          example: 25
          minimum: 0
      required:
      - current_page
      - items
      - total_items
      - total_pages
    ProductAttributeDTO:
      type: object
      properties:
        attribute_id:
          type: integer
          format: int64
          description: ID атрибута
          example: 3
        attribute_name:
          type: string
          description: Название атрибута
          example: Цвет
        value:
          type: string
          description: Значение атрибута
          example: Синий
      required:
      - attribute_id
      - attribute_name
      - value
    ProductPageResponseDTO:
      type: object
      properties:
        products:
          type: array
          description: Список товаров
          items:
            $ref: "#/components/schemas/ProductResponseDTO"
        current_page:
          type: integer
          format: int32
          description: Текущая страница
          example: 1
          minimum: 0
        total_pages:
          type: integer
          format: int32
          description: Всего страниц
          example: 5
          minimum: 0
        total_products:
          type: integer
          format: int64
          description: Общее количество товаров
          example: 100
          minimum: 0
      required:
      - current_page
      - products
      - total_pages
      - total_products
    ProductResponseDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: Уникальный ID товара в системе
          example: 1
        article_number:
          type: integer
          format: int64
          description: Артикул товара
          example: 123456789
        name:
          type: string
          description: Название товара
          example: Смартфон Xiaomi Redmi Note 12
        number_of_orders:
          type: integer
          format: int64
        price:
          type: number
          format: double
          description: Цена товара
          example: 19999.99
        rating:
          type: number
          format: double
          description: Средний рейтинг товара
          example: 4.5
          maximum: 5
          minimum: 0
        attributes:
          type: array
          description: Список атрибутов товара
          items:
            $ref: "#/components/schemas/ProductAttributeDTO"
        category_id:
          type: integer
          format: int64
          description: ID категории товара
          example: 5
        category_name:
          type: string
          description: Название категории
          example: Смартфоны
        photos:
          type: array
          description: Ссылки на фотографии товара
          example: "['https://storage.example.com/photo1.jpg', 'https://storage.example.com/photo2.jpg']"
          items:
            type: string
        reviews:
          type: array
          description: Список отзывов о товаре
          items:
            $ref: "#/components/schemas/ReviewDTO"
      required:
      - article_number
      - attributes
      - category_id
      - category_name
      - id
      - name
      - number_of_orders
      - photos
      - price
      - rating
      - reviews
    OrderPageResponseDTO:
      type: object
      properties:
        orders:
          type: array
          description: Список заказов
          items:
            $ref: "#/components/schemas/OrderDTO"
        current_page:
          type: integer
          format: int32
          description: Текущая страница
          example: 1
          minimum: 0
        total_pages:
          type: integer
          format: int32
          description: Всего страниц
          example: 3
          minimum: 0
        total_orders:
          type: integer
          format: int64
          description: Общее количество заказов
          example: 25
          minimum: 0
      required:
      - current_page
      - orders
      - total_orders
      - total_pages
    UserResponse:
      type: object
      properties:
        id:
          type: integer
          format: int64
      required:
      - id
    CategoryResponseDTO:
      type: object
      properties:
        categories:
          type: object
          additionalProperties:
            type: integer
            format: int64
          description: "Категории в формате: Название -> ID"
          example:
            Смартфоны: 1
            Ноутбуки: 2
      required:
      - categories
    AttributeDTO:
      type: object
      properties:
        id:
          type: integer
          format: int64
          description: ID атрибута
          example: 5
        name:
          type: string
          description: Название атрибута
          example: Цвет
        values:
          type: array
          description: Допустимые значения атрибута
          example:
          - Красный
          - Синий
          items:
            type: string
      required:
      - id
      - name
      - values
    CategoryAttributesResponseDTO:
      type: object
      properties:
        category_id:
          type: integer
          format: int64
          description: ID категории
          example: 5
        category_name:
          type: string
          description: Название категории
          example: Смартфоны
        attributes:
          type: array
          description: Список атрибутов категории
          items:
            $ref: "#/components/schemas/AttributeDTO"
      required:
      - attributes
      - category_id
      - category_name
    CartPageResponseDTO:
      type: object
      properties:
        items:
          type: array
          description: Список товаров в корзине
          items:
            $ref: "#/components/schemas/CartItemDTO"
        current_page:
          type: integer
          format: int32
          description: Текущая страница
          example: 1
        total_pages:
          type: integer
          format: int32
          description: Всего страниц
          example: 3
        total_items:
          type: integer
          format: int64
          description: Общее количество товаров
          example: 25
      required:
      - current_page
      - items
      - total_items
      - total_pages
  securitySchemes:
    Bearer Authentication:
      type: http
      scheme: bearer
      bearerFormat: JWT
```
```typescript
import { AuthResponse } from '../types/auth'
import api from '../utils/api'

export const AuthService = {
	authenticate: () =>
		api.post<AuthResponse>('/auth/authenticate').then(res => res.data),
	refreshToken: (refreshToken: string) =>
		api
			.post<AuthResponse>('/auth/token/refresh', { refreshToken })
			.then(res => res.data),
	logout: () => api.post('/logout').then(res => res.data),
}


import { AddToCartRequest, CartItem, CartPageResponse } from '../types/cart'
import api from '../utils/api'

export const CartService = {
	addItem: (data: AddToCartRequest) =>
		api.post('/cart/add', data).then(res => res.data),
	removeItem: (article: number) =>
		api.delete(`/cart/remove?article=${article}`).then(res => res.data),
	getCart: (page: number = 0, size: number = 20) =>
		api
			.get<CartPageResponse>(`/cart/list?page=${page}&size=${size}`)
			.then(res => res.data),
	getAllCartItems: () =>
		api
			.get<CartPageResponse>('/cart/list?size=1000')
			.then(res => res.data.items),
	checkInCart: (article: number) =>
		api
			.get<CartItem>(`/cart/checkin?article=${article}`)
			.then(res => res.data?.quantity || 0),
}

import { CategoryAttributesResponse, CategoryResponse } from '../types/category'
import api from '../utils/api'

export const CategoryService = {
	getAll: () => api.get<CategoryResponse>('/category').then(res => res.data),
	getAttributes: (categoryId: number) =>
		api
			.get<CategoryAttributesResponse>(`/category/${categoryId}`)
			.then(res => res.data),
}

import { CreateOrderRequest, OrderDTO, OrderPageResponse } from '../types/order'
import api from '../utils/api'

export const OrderService = {
	create: (data: CreateOrderRequest) =>
		api.post<OrderDTO>('/orders/create', data).then(res => res.data),
	cancel: (orderId: number) =>
		api
			.delete<OrderDTO>(`/orders/cancel?orderId=${orderId}`)
			.then(res => res.data),
	getOrders: (page: number, size: number = 20) =>
		api
			.get<OrderPageResponse>(`/orders/list?page=${page}&size=${size}`)
			.then(res => res.data),
}

import { ProductPageResponse, ProductResponse } from '../types/product'
import api from '../utils/api'

const buildSortParams = (sortOption?: string) => {
	if (!sortOption) return undefined
	const sortMapping: Record<string, string> = {
		price_asc: 'price,asc',
		price_desc: 'price,desc',
		rating: 'rating,desc',
		orders: 'numberOfOrders,desc',
	}
	return sortMapping[sortOption] || undefined
}

export const ProductService = {
	getProduct: (article: number) =>
		api.get<ProductResponse>(`/products/${article}`).then(res => res.data),

	getAll: (page: number, size: number = 20, sort?: string) =>
		api
			.get<ProductPageResponse>('/products', {
				params: {
					page,
					size,
					sort: buildSortParams(sort),
				},
			})
			.then(res => res.data),

	getByCategory: (
		categoryId: number,
		page: number,
		size: number = 20,
		sort?: string
	) =>
		api
			.get<ProductPageResponse>(`/products/category/${categoryId}`, {
				params: {
					page,
					size,
					sort: buildSortParams(sort),
				},
			})
			.then(res => res.data),

	search: (
		searchQuery: string,
		page: number,
		size: number = 20,
		sort?: string
	) =>
		api
			.get<ProductPageResponse>('/products/search', {
				params: {
					query: searchQuery,
					page,
					size,
					sort: buildSortParams(sort),
				},
			})
			.then(res => res.data),

	searchWithFilters: (
		categoryId: number,
		filters: Record<number, string[]>,
		page: number,
		size: number = 20,
		sort?: string
	) => {
		const params = new URLSearchParams({
			categoryId: categoryId.toString(),
			page: page.toString(),
			size: size.toString(),
		})

		const sortParam = buildSortParams(sort)
		if (sortParam) {
			params.append('sort', sortParam)
		}

		Object.entries(filters).forEach(([attrId, values]) => {
			values.forEach(value => params.append(`attributes[${attrId}]`, value))
		})

		return api
			.get<ProductPageResponse>(`/products/search?${params}`)
			.then(res => res.data)
	},
}

import { PhotoReviewRequest, ReviewDTO, ReviewResponse } from '../types/review'
import api from '../utils/api'

export const ReviewService = {
	create: (article: number, data: ReviewDTO) =>
		api
			.post<ReviewResponse>(`/review?article=${article}`, data)
			.then(res => res.data),

	uploadPhoto: (data: PhotoReviewRequest, file: File) => {
		const formData = new FormData()
		formData.append('file', file)
		formData.append('reviewId', data.review_id.toString())
		formData.append('indexNumber', data.index_number.toString())
		return api
			.post<string>('/review/photo', formData, {
				headers: { 'Content-Type': 'multipart/form-data' },
			})
			.then(res => res.data)
	},
}

import { WishListItem, WishListPageResponse } from '../types/wishlist'
import api from '../utils/api'

export const WishListService = {
	addItem: (article: number) =>
		api
			.post<WishListItem>(`/wishlist/add?article=${article}`)
			.then(res => res.data),

	removeItem: (article: number) =>
		api
			.delete<WishListItem>(`/wishlist/remove?article=${article}`)
			.then(res => res.data),

	getList: (page: number = 0, size: number = 20) =>
		api
			.get<WishListPageResponse>(`/wishlist/list?page=${page}&size=${size}`)
			.then(res => res.data),

	getAllWishlistItems: () =>
		api
			.get<WishListPageResponse>('/wishlist/list?size=1000')
			.then(res => res.data.items),
	checkInWishlist: (article: number) =>
		api
			.get<boolean>(`/wishlist/checkin?article=${article}`)
			.then(res => res.data),
}



import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			staleTime: 5 * 60 * 1000,
			gcTime: 15 * 60 * 1000,
			retry: 2,
			refetchOnWindowFocus: false,
			retryDelay: attempt => Math.min(attempt * 1000, 30 * 1000),
		},
	},
})

export const QueryProvider = ({ children }: { children: React.ReactNode }) => (
	<QueryClientProvider client={queryClient}>
		{children}
		<ReactQueryDevtools position='bottom' />
	</QueryClientProvider>
)


import { MenuOutlined } from '@ant-design/icons'
import styles from './BurgerMenu.module.scss'

type BurgerMenuProps = {
	onClick: () => void
}

export const BurgerMenu = ({ onClick }: BurgerMenuProps) => {
	return (
		<button className={styles.burgerButton} onClick={onClick}>
			<MenuOutlined className={styles.icon} />
		</button>
	)
}


.burgerButton {
	background: rgba(255, 255, 255, 0.1);
	border: 1px solid rgba(255, 255, 255, 0.3);
	border-radius: 8px;
	padding: 8px 12px;
	margin-left: 16px;
	transition: all 0.3s;

	.icon {
		font-size: 20px;
		color: white;
	}

	&:hover {
		background: rgba(255, 255, 255, 0.2);
		border-color: rgba(255, 255, 255, 0.5);
	}
}


import { Button, Select, Typography } from 'antd'
import type { CategoryAttributesResponse } from '../../types/category'
import styles from './FilterForm.module.scss'

const { Title } = Typography

type FilterFormProps = {
	categories: Array<[string, number]>
	attributes: CategoryAttributesResponse['attributes']
	selectedCategory: number | null
	selectedFilters: Record<number, string[]>
	onCategoryChange: (categoryId: number) => void
	onFilterChange: (attributeId: number, values: string[]) => void
	onApply: () => void
	onReset: () => void
}

export const FilterForm = ({
	categories,
	attributes,
	selectedCategory,
	selectedFilters,
	onCategoryChange,
	onFilterChange,
	onApply,
	onReset,
}: FilterFormProps) => {
	return (
		<div className={styles.filterForm}>
			<div className={styles.section}>
				<Title level={5} className={styles.title}>
					Категория
				</Title>
				<Select
					placeholder='Выберите категорию'
					options={categories.map(([name, id]) => ({
						label: name,
						value: id,
					}))}
					value={selectedCategory}
					onChange={onCategoryChange}
					style={{ width: '100%' }}
				/>
			</div>

			{selectedCategory && attributes.length > 0 && (
				<div className={styles.section}>
					{attributes.map(attr => (
						<div key={attr.id} className={styles.filterGroup}>
							<div className={styles.filterName}>{attr.name}</div>
							<Select
								mode='multiple'
								placeholder={`Выберите ${attr.name}`}
								value={selectedFilters[attr.id] || []}
								onChange={values => onFilterChange(attr.id, values)}
								options={attr.values.map(value => ({
									label: value,
									value: value,
								}))}
								style={{ width: '100%' }}
								dropdownMatchSelectWidth={false}
								popupClassName={styles.selectDropdown}
								showSearch
								filterOption={(input, option) =>
									(option?.label ?? '')
										.toLowerCase()
										.includes(input.toLowerCase())
								}
							/>
						</div>
					))}
				</div>
			)}

			<div className={styles.actions}>
				<Button onClick={onReset}>Сбросить</Button>
				<Button type='primary' onClick={onApply}>
					Показать товары
				</Button>
			</div>
		</div>
	)
}

.filterForm {
	display: flex;
	flex-direction: column;
	gap: 24px;
	padding: 16px;

	.section {
		background: #f5f5f5;
		padding: 16px;
		border-radius: 8px;
		border: 1px solid #e8e8e8;
	}

	.title {
		margin-bottom: 12px !important;
		color: #1890ff;
	}

	.filterGroup {
		margin-bottom: 12px;

		.filterName {
			font-weight: 500;
			margin-bottom: 6px;
			color: rgba(0, 0, 0, 0.85);
		}
	}

	.checkbox {
		display: block;
		margin: 4px 0;

		:global(.ant-checkbox-inner) {
			border-radius: 4px;
		}
	}

	.actions {
		display: flex;
		justify-content: space-between;
		margin-top: 24px;
		gap: 16px;

		button {
			flex: 1;
		}
	}
}
.selectDropdown {
	:global {
		.ant-select-item-option-content {
			white-space: normal !important;
		}
		.ant-select-dropdown {
			max-width: 600px;
		}
	}
}


import {
	HeartOutlined,
	HomeOutlined,
	ShoppingCartOutlined,
	UserOutlined,
} from '@ant-design/icons'
import { Link } from 'react-router-dom'
import styles from './Navbar.module.scss'

type NavItem = {
	path: string
	icon: React.ReactNode
	label: string
}

const navItems: NavItem[] = [
	{ path: '/', icon: <HomeOutlined />, label: 'Главная' },
	{ path: '/wishlist', icon: <HeartOutlined />, label: 'Избранное' },
	{ path: '/profile', icon: <UserOutlined />, label: 'Профиль' },
	{ path: '/cart', icon: <ShoppingCartOutlined />, label: 'Корзина' },
]

export const Navbar = ({ activePath }: { activePath: string }) => {
	return (
		<nav className={styles.navbar}>
			{navItems.map(item => (
				<Link
					key={item.path}
					to={item.path}
					className={`${styles.navItem} ${
						activePath === item.path ? styles.active : ''
					}`}
					aria-label={item.label}
				>
					{item.icon}
				</Link>
			))}
		</nav>
	)
}

.navbar {
	position: fixed;
	bottom: 0;
	left: 0;
	right: 0;
	display: flex;
	justify-content: space-around;
	align-items: center;
	height: 64px;
	background: white;
	box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
	z-index: 1000;

	.navItem {
		padding: 12px;
		font-size: 24px;
		color: rgba(0, 0, 0, 0.65);
		transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);
		transform: scale(1);

		&:hover {
			color: #1890ff;
			transform: scale(1.1);
		}

		&.active {
			color: #1890ff;
			transform: scale(1.15);
		}
	}
}


import {
	HeartFilled,
	HeartOutlined,
	ShoppingCartOutlined,
} from '@ant-design/icons'
import { Button, Rate, Space } from 'antd'
import { Link } from 'react-router-dom'
import type { ProductResponse } from '../../types/product'
import styles from './ProductCard.module.scss'

type ProductCardProps = {
	product: ProductResponse
	onCartAction: (product: ProductResponse, action: 'add' | 'remove') => void
	onWishlistAction: (article: number) => void
	isInWishlist?: boolean
	cartQuantity?: number
}

export const ProductCard = ({
	product,
	onCartAction,
	onWishlistAction,
	isInWishlist = false,
	cartQuantity = 0,
}: ProductCardProps) => {
	return (
		<div className={styles.card}>
			<Link
				to={`/product/${product.article_number}`}
				className={styles.imageLink}
			>
				<img
					src={product.photos[0] || '/placeholder-product.jpg'}
					alt={product.name}
					className={styles.image}
				/>
			</Link>

			<div className={styles.content}>
				<h3 className={styles.title}>{product.name}</h3>

				<div className={styles.meta}>
					<Rate value={product.rating} disabled className={styles.rating} />
					<span className={styles.price}>{product.price} ₽</span>
				</div>

				<div className={styles.actions}>
					{cartQuantity > 0 ? (
						<Space className={styles.quantityControl}>
							<Button
								type='primary'
								danger
								onClick={() => onCartAction(product, 'remove')}
							>
								-
							</Button>
							<span className={styles.quantity}>{cartQuantity}</span>
							<Button
								type='primary'
								onClick={() => onCartAction(product, 'add')}
							>
								+
							</Button>
						</Space>
					) : (
						<Button
							type='primary'
							icon={<ShoppingCartOutlined />}
							onClick={() => onCartAction(product, 'add')}
						>
							В корзину
						</Button>
					)}

					<Button
						type={isInWishlist ? 'primary' : 'default'}
						icon={isInWishlist ? <HeartFilled /> : <HeartOutlined />}
						onClick={() => onWishlistAction(product.article_number)}
					/>
				</div>
			</div>
		</div>
	)
}

.card {
	background: white;
	border-radius: 8px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	overflow: hidden;
	transition: transform 0.3s;

	&:hover {
		transform: translateY(-4px);
	}
}

.quantityControl {
	display: flex;
	align-items: center;
	gap: 8px;

	.quantity {
		min-width: 24px;
		text-align: center;
		font-weight: 500;
	}
}

.actions {
	display: flex;
	gap: 8px;
	margin-top: 12px;

	.ant-btn {
		flex: 1;
	}
}

.imageLink {
	display: block;
	height: 240px;
	overflow: hidden;
}

.image {
	width: 100%;
	height: 100%;
	object-fit: cover;
	transition: transform 0.3s;

	&:hover {
		transform: scale(1.05);
	}
}

.content {
	padding: 16px;
}

.title {
	font-size: 16px;
	margin-bottom: 8px;
	color: rgba(0, 0, 0, 0.85);
}

.meta {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 16px;
}

.price {
	font-size: 18px;
	font-weight: 600;
	color: #1890ff;
}

.actions {
	display: flex;
	gap: 8px;
	margin-top: 12px;

	.ant-btn {
		flex: 1;
	}
}


import { SearchOutlined } from '@ant-design/icons'
import { Input } from 'antd'
import styles from './SearchBar.module.scss'

type SearchBarProps = {
	onSearch: (value: string) => void
}

export const SearchBar = ({ onSearch }: SearchBarProps) => {
	return (
		<Input
			placeholder='Поиск товаров...'
			prefix={<SearchOutlined className={styles.icon} />}
			className={styles.searchInput}
			onChange={e => onSearch(e.target.value)}
			allowClear
		/>
	)
}

.searchInput {
	width: 100%;
	max-width: 600px;
	border-radius: 20px;
	padding: 8px 16px;

	.icon {
		color: rgba(0, 0, 0, 0.25);
	}
}


import { DownOutlined } from '@ant-design/icons'
import type { MenuProps } from 'antd'
import { Button, Dropdown } from 'antd'
import styles from './SortControl.module.scss'

export type SortOption = 'price_asc' | 'price_desc' | 'rating' | 'orders'

type SortControlProps = {
	currentSort: SortOption
	onSortChange: (value: SortOption) => void
}

const labels: Record<SortOption, string> = {
	price_asc: 'Сначала дешевые',
	price_desc: 'Сначала дорогие',
	rating: 'По рейтингу',
	orders: 'По количеству заказов',
}

export const SortControl = ({
	currentSort,
	onSortChange,
}: SortControlProps) => {
	const items: MenuProps['items'] = Object.entries(labels).map(
		([key, label]) => ({
			key,
			label: <span className={styles.menuItem}>{label}</span>,
		})
	)

	return (
		<Dropdown
			menu={{
				items,
				selectable: true,
				defaultSelectedKeys: [currentSort],
				onClick: ({ key }) => onSortChange(key as SortOption),
			}}
			trigger={['click']}
		>
			<Button className={styles.sortButton}>
				{labels[currentSort]}
				<DownOutlined className={styles.icon} />
			</Button>
		</Dropdown>
	)
}
.sortButton {
	display: flex;
	align-items: center;
	gap: 8px;
	padding: 8px 16px;
	border-radius: 6px;
	border: 1px solid #d9d9d9;
	background: #fff;

	&:hover {
		border-color: #40a9ff;
		color: #40a9ff;
	}
}

.icon {
	font-size: 12px;
	transition: transform 0.2s;
}

.menuItem {
	padding: 8px 12px;
	display: block;
}


import { useLocation } from 'react-router-dom'
import { Navbar } from '../../components/Navbar/Navbar'

export const NavbarContainer = () => {
	const location = useLocation()
	return <Navbar activePath={location.pathname} />
}


import { Button, Spin } from 'antd'
import { useMemo } from 'react'
import { ProductCard } from '../../components/ProductCard/ProductCard'
import { useCartActions } from '../../hooks/useCart'
import { useProducts } from '../../hooks/useProducts'
import { useWishlistActions } from '../../hooks/useWishList'
import { ProductResponse } from '../../types/product'
import styles from './ProductListContainer.module.scss'

export const ProductListContainer = () => {
	const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useProducts()

	const { addToCart, removeFromCart } = useCartActions()
	const { addToWishlist, removeFromWishlist } = useWishlistActions()
	const enrichedProducts = useMemo(() => data?.products || [], [data])

	const handleCartAction = (
		product: ProductResponse,
		action: 'add' | 'remove'
	) => {
		if (action === 'add') {
			addToCart.mutate({ article_number: product.article_number, quantity: 1 })
		} else {
			if (product.inCart === 1) {
				removeFromCart.mutate(product.article_number)
			} else {
				addToCart.mutate({
					article_number: product.article_number,
					quantity: -1,
				})
			}
		}
	}

	return (
		<div className={styles.container}>
			<div className={styles.grid}>
				{enrichedProducts.map(product => (
					<ProductCard
						key={product.article_number}
						product={product}
						onCartAction={handleCartAction}
						onWishlistAction={() =>
							product.inWishlist
								? removeFromWishlist.mutate(product.article_number)
								: addToWishlist.mutate(product.article_number)
						}
						isInWishlist={product.inWishlist}
						cartQuantity={product.inCart}
					/>
				))}
			</div>

			{hasNextPage && (
				<div className={styles.loadMore}>
					<Button
						type='primary'
						loading={isFetchingNextPage}
						onClick={() => fetchNextPage()}
					>
						Показать еще
					</Button>
				</div>
			)}

			{isFetchingNextPage && <Spin className={styles.spinner} />}
		</div>
	)
}

.container {
	padding: 24px;
}

.grid {
	display: grid;
	grid-template-columns: repeat(2, 1fr);
	gap: 16px;
	padding: 16px;
}

.loadMore {
	display: flex;
	justify-content: center;
	margin: 24px 0;
}

.spinner {
	display: block;
	margin: 24px auto;
}


import { Modal, Spin } from 'antd'
import { useState } from 'react'
import { useSearchParams } from 'react-router-dom'
import { BurgerMenu } from '../../components/BurgerMenu/BurgerMenu'
import { FilterForm } from '../../components/FilterForm/FilterForm'
import { SearchBar } from '../../components/SearchBar/SearchBar'
import { useCategoryFilters } from '../../hooks/useCategoryFilters'
import styles from './SearchContainer.module.scss'

export const SearchContainer = () => {
	const [isModalOpen, setIsModalOpen] = useState(false)
	const [searchParams, setSearchParams] = useSearchParams()
	const {
		categories,
		attributes,
		selectedCategory,
		selectedFilters,
		isLoading,
		handleCategoryChange,
		handleFilterChange,
		resetFilters,
	} = useCategoryFilters()

	const handleSearch = (value: string) => {
		const newParams = new URLSearchParams(searchParams)
		if (value) {
			newParams.set('search', value)
		} else {
			newParams.delete('search')
		}
		newParams.set('page', '0')
		setSearchParams(newParams)
	}

	const handleApplyFilters = () => {
		const newParams = new URLSearchParams()

		if (selectedCategory) {
			newParams.set('categoryId', selectedCategory.toString())
			newParams.set('page', '0')

			Object.entries(selectedFilters).forEach(([attrId, values]) => {
				values.forEach(value =>
					newParams.append(`attributes[${attrId}]`, value)
				)
			})
		}

		// Сохраняем параметры поиска при применении фильтров
		const searchQuery = searchParams.get('search')
		if (searchQuery) newParams.set('search', searchQuery)

		setSearchParams(newParams)
		setIsModalOpen(false)
	}

	const handleResetFilters = () => {
		resetFilters()
		setSearchParams(new URLSearchParams({ page: '0' }))
		setIsModalOpen(false)
	}

	return (
		<div className={styles.container}>
			<SearchBar onSearch={handleSearch} />
			<BurgerMenu onClick={() => setIsModalOpen(true)} />

			<Modal
				title='Фильтры'
				open={isModalOpen}
				onCancel={() => setIsModalOpen(false)}
				footer={null}
				centered
				width='90%'
				style={{ top: '5vh', maxWidth: '1440px' }}
				bodyStyle={{ height: '85vh', overflowY: 'auto', padding: '16px 24px' }}
			>
				<div className={styles.modalContent}>
					{isLoading ? (
						<Spin />
					) : (
						<FilterForm
							categories={categories}
							attributes={attributes}
							selectedCategory={selectedCategory}
							selectedFilters={selectedFilters}
							onCategoryChange={handleCategoryChange}
							onFilterChange={handleFilterChange}
							onApply={handleApplyFilters}
							onReset={handleResetFilters}
						/>
					)}
				</div>
			</Modal>
		</div>
	)
}
.container {
	display: flex;
	justify-content: space-between;
	align-items: center;
	gap: 16px;
	padding: 12px 24px;
	background: #1890ff;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
	position: sticky;
	top: 0;
	width: 100%;
	z-index: 1000;
	.modalContent {
		max-height: 70vh;
		overflow-y: auto;
		padding: 8px;

		:global(.ant-spin) {
			display: flex;
			justify-content: center;
			padding: 24px 0;
		}
	}
}


import { useState } from 'react'
import { useSearchParams } from 'react-router-dom'
import {
	SortControl,
	SortOption,
} from '../../components/SortControl/SortControl'

export const SortContainer = () => {
	const [searchParams, setSearchParams] = useSearchParams()
	const [currentSort, setCurrentSort] = useState<SortOption>(
		(searchParams.get('sort') as SortOption) || 'price_asc'
	)

	const handleSortChange = (value: SortOption) => {
		const newParams = new URLSearchParams(searchParams)
		newParams.set('sort', value)
		newParams.set('page', '0')
		setCurrentSort(value)
		setSearchParams(newParams)
	}

	return (
		<SortControl currentSort={currentSort} onSortChange={handleSortChange} />
	)
}


import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { AuthService } from '../api/auth'

export const useAuth = () => {
	const queryClient = useQueryClient()

	const {
		data: authData,
		isLoading: isAuthLoading,
		error: authError,
	} = useQuery({
		queryKey: ['auth'],
		queryFn: async () => {
			try {
				const data = await AuthService.authenticate()
				localStorage.setItem('accessToken', data.access_token)
				localStorage.setItem('refreshToken', data.refresh_token)
				return { isAuthenticated: true }
			} catch (error) {
				localStorage.removeItem('accessToken')
				localStorage.removeItem('refreshToken')
				throw error
			}
		},
		retry: 0,
		staleTime: Infinity,
	})

	const logout = useMutation({
		mutationFn: AuthService.logout,
		onSuccess: () => {
			localStorage.removeItem('accessToken')
			localStorage.removeItem('refreshToken')
			queryClient.clear()
		},
	})

	const refresh = useMutation({
		mutationFn: (refreshToken: string) =>
			AuthService.refreshToken(refreshToken),
		onSuccess: data => {
			localStorage.setItem('accessToken', data.access_token)
			localStorage.setItem('refreshToken', data.refresh_token)
		},
	})

	return {
		authData,
		isAuthLoading,
		authError,
		logout,
		refresh,
	}
}
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { CartService } from '../api/cart'

export const useCart = (page: number = 0) => {
	return useQuery({
		queryKey: ['cart', page],
		queryFn: () => CartService.getCart(page),
		placeholderData: previousData => previousData,
	})
}

export const useCartActions = () => {
	const queryClient = useQueryClient()

	const addToCart = useMutation({
		mutationFn: CartService.addItem,
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['cart'] })
			queryClient.invalidateQueries({ queryKey: ['cart-status'] })
			queryClient.invalidateQueries({ queryKey: ['products'] })
		},
	})

	const removeFromCart = useMutation({
		mutationFn: CartService.removeItem,
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['cart'] })
			queryClient.invalidateQueries({ queryKey: ['cart-status'] })
			queryClient.invalidateQueries({ queryKey: ['products'] })
		},
	})

	return { addToCart, removeFromCart }
}
import { useQuery } from '@tanstack/react-query'
import { CategoryService } from '../api/category'

export const useCategories = () => {
	return useQuery({
		queryKey: ['categories'],
		queryFn: CategoryService.getAll,
	})
}

export const useCategoryAttributes = (categoryId: number) => {
	return useQuery({
		queryKey: ['categoryAttributes', categoryId],
		queryFn: () => CategoryService.getAttributes(categoryId),
		enabled: !!categoryId,
	})
}
import { useQuery } from '@tanstack/react-query'
import { useState } from 'react'
import { useSearchParams } from 'react-router-dom'
import { CategoryService } from '../api/category'
import type {
	CategoryAttributesResponse,
	CategoryResponse,
} from '../types/category'

export const useCategoryFilters = () => {
	const [searchParams] = useSearchParams()
	const initialCategory = Number(searchParams.get('categoryId')) || null

	const [selectedCategory, setSelectedCategory] = useState<number | null>(
		initialCategory
	)
	const [selectedFilters, setSelectedFilters] = useState<
		Record<number, string[]>
	>(() => {
		const filters: Record<number, string[]> = {}
		searchParams.forEach((value, key) => {
			const match = key.match(/attributes\[(\d+)\]/)
			if (match) {
				const attrId = parseInt(match[1], 10)
				filters[attrId] = [...(filters[attrId] || []), value]
			}
		})
		return filters
	})

	const { data: categories } = useQuery<CategoryResponse>({
		queryKey: ['categories'],
		queryFn: CategoryService.getAll,
	})

	const { data: attributes, isLoading } = useQuery<CategoryAttributesResponse>({
		queryKey: ['categoryAttributes', selectedCategory],
		queryFn: () => {
			if (!selectedCategory) throw new Error('Category not selected')
			return CategoryService.getAttributes(selectedCategory)
		},
		enabled: !!selectedCategory,
	})

	const handleCategoryChange = (categoryId: number) => {
		setSelectedCategory(categoryId)
		setSelectedFilters({})
	}

	const handleFilterChange = (attributeId: number, values: string[]) => {
		setSelectedFilters(prev => ({
			...prev,
			[attributeId]: values,
		}))
	}

	const resetFilters = () => {
		setSelectedCategory(null)
		setSelectedFilters({})
	}

	return {
		categories: categories?.categories
			? Object.entries(categories.categories)
			: [],
		attributes: attributes?.attributes || [],
		selectedCategory,
		selectedFilters,
		isLoading,
		handleCategoryChange,
		handleFilterChange,
		resetFilters,
	}
}
import { useQueries } from '@tanstack/react-query'
import {
	CartService,
	OrderService,
	ProductService,
	WishListService,
} from '../api'
import { useAuth } from './useAuth'

export const useInitialData = (page: number = 0) => {
	const { authData } = useAuth()
	return useQueries({
		queries: [
			{
				queryKey: ['products', page],
				queryFn: () => ProductService.getAll(page),
				staleTime: 1000 * 60 * 5,
				enabled: !!authData?.isAuthenticated,
			},
			{
				queryKey: ['orders', page],
				queryFn: () => OrderService.getOrders(page),
				enabled: !!authData?.isAuthenticated,
			},
			{
				queryKey: ['wishlist', page],
				queryFn: () => WishListService.getList(page),
				enabled: !!authData?.isAuthenticated,
			},
			{
				queryKey: ['cart', page],
				queryFn: () => CartService.getCart(page),
				enabled: !!authData?.isAuthenticated,
			},
		],
	})
}
import {
	keepPreviousData,
	useMutation,
	useQuery,
	useQueryClient,
} from '@tanstack/react-query'
import { OrderService } from '../api'
import { OrderDTO, OrderPageResponse } from '../types/order'

export const useOrders = (page: number = 0) => {
	return useQuery<OrderPageResponse, Error>({
		queryKey: ['orders', page],
		queryFn: () => OrderService.getOrders(page),
		enabled: !!localStorage.getItem('accessToken'),
		placeholderData: keepPreviousData,
	})
}

export const useOrderActions = () => {
	const queryClient = useQueryClient()

	const createOrder = useMutation({
		mutationFn: OrderService.create,
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['orders', 'cart'] })
		},
	})

	const cancelOrder = useMutation<OrderDTO, Error, number>({
		mutationFn: orderId => OrderService.cancel(orderId),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['orders'] })
		},
	})

	return { createOrder, cancelOrder }
}
import {
	keepPreviousData,
	useInfiniteQuery,
	useQuery,
} from '@tanstack/react-query'
import { useSearchParams } from 'react-router-dom'
import { ProductService } from '../api/product'
import type { ProductPageResponse, ProductResponse } from '../types/product'
import { useProductStatus } from './useProductStatus'

export const useProducts = () => {
	const [searchParams] = useSearchParams()
	//const page = Number(searchParams.get('page')) || 0
	const categoryId = Number(searchParams.get('categoryId')) || undefined
	const sort = searchParams.get('sort') || undefined
	const searchQuery = searchParams.get('search') || undefined

	const { cartMap, wishlistSet, isLoading: statusLoading } = useProductStatus()

	const query = useInfiniteQuery<ProductPageResponse>({
		queryKey: [
			'products',
			{
				categoryId,
				sort,
				search: searchQuery,
				...Object.fromEntries(searchParams),
			},
		],
		queryFn: ({ pageParam = 0 }) => {
			const filters = Array.from(searchParams.entries()).reduce(
				(acc, [key, value]) => {
					if (key.startsWith('attributes[')) {
						const attrId = key.match(/\[(.*?)\]/)?.[1]
						if (attrId) {
							acc[Number(attrId)] = [...(acc[Number(attrId)] || []), value]
						}
					}
					return acc
				},
				{} as Record<number, string[]>
			)

			if (searchQuery) {
				return ProductService.search(searchQuery, pageParam as number)
			}

			if (categoryId) {
				return ProductService.searchWithFilters(
					categoryId,
					filters,
					pageParam as number,
					20,
					sort
				)
			}

			return ProductService.getAll(pageParam as number, 20, sort)
		},
		initialPageParam: 0,
		getNextPageParam: lastPage => {
			return lastPage.current_page < lastPage.total_pages
				? lastPage.current_page + 1
				: undefined
		},
		placeholderData: keepPreviousData,
		staleTime: 1000 * 60 * 5,
		enabled: !statusLoading,
	})

	const enrichedProducts =
		query.data?.pages.flatMap(page =>
			page.products.map(product => ({
				...product,
				inCart: cartMap.get(product.article_number) || 0,
				inWishlist: wishlistSet.has(product.article_number),
			}))
		) || []

	return {
		...query,
		data: {
			products: enrichedProducts,
			current_page: query.data?.pages.at(-1)?.current_page || 0,
			total_pages: query.data?.pages.at(-1)?.total_pages || 0,
		},
	}
}
export const useProductDetails = (article: number) => {
	return useQuery<ProductResponse, Error>({
		queryKey: ['product', article],
		queryFn: () => ProductService.getProduct(article),
		enabled: !!article,
	})
}
// *


// hooks/useProductStatus.ts
import { useQuery } from '@tanstack/react-query'
import { CartService, WishListService } from '../api'

export const useProductStatus = () => {
	const cartQuery = useQuery({
		queryKey: ['cart-status'],
		queryFn: () => CartService.getAllCartItems(),
		staleTime: 1000 * 60 * 2,
		refetchOnWindowFocus: true,
	})

	const wishlistQuery = useQuery({
		queryKey: ['wishlist-status'],
		queryFn: () => WishListService.getAllWishlistItems(),
		staleTime: 1000 * 60 * 2,
		refetchOnWindowFocus: true,
	})

	const cartItems = cartQuery.data || []
	const wishlistItems = wishlistQuery.data || []

	return {
		cartMap: new Map(
			cartItems.map(item => [item.article_number, item.quantity])
		) as unknown as Map<number, number>,
		wishlistSet: new Set(
			wishlistItems.map(item => item.article_number)
		) as Set<number>,
		isLoading: cartQuery.isLoading || wishlistQuery.isLoading,
		error: cartQuery.error || wishlistQuery.error,
	}
}



import { useMutation } from '@tanstack/react-query'
import { AuthService } from '../api/auth'

export const useRefreshToken = () => {
	return useMutation({
		mutationFn: (refreshToken: string) =>
			AuthService.refreshToken(refreshToken),
		onSuccess: data => {
			localStorage.setItem('accessToken', data.access_token)
			localStorage.setItem('refreshToken', data.refresh_token)
		},
	})
}


import { useMutation, useQueryClient } from '@tanstack/react-query'
import { ReviewService } from '../api'
import { ReviewDTO } from '../types/review'

export const useReviewActions = () => {
	const queryClient = useQueryClient()

	const createReview = useMutation({
		mutationFn: (data: { article: number; review: ReviewDTO }) =>
			ReviewService.create(data.article, data.review),
		onSuccess: (_, vars) => {
			queryClient.invalidateQueries({
				queryKey: ['reviews', vars.article],
			})
			queryClient.invalidateQueries({
				queryKey: ['product', vars.article],
			})
		},
	})

	const uploadPhoto = useMutation({
		mutationFn: (data: { reviewId: number; index: number; file: File }) =>
			ReviewService.uploadPhoto(
				{ review_id: data.reviewId, index_number: data.index },
				data.file
			),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['reviews'] })
		},
	})

	return { createReview, uploadPhoto }
}


import {
	keepPreviousData,
	useMutation,
	useQuery,
	useQueryClient,
} from '@tanstack/react-query'
import { WishListService } from '../api/wishlist'
import { WishListPageResponse } from '../types/wishlist'

export const useWishlist = (page: number = 1) => {
	return useQuery<WishListPageResponse, Error>({
		queryKey: ['wishlist', page],
		queryFn: () => WishListService.getList(page),
		placeholderData: keepPreviousData,
	})
}

export const useWishlistActions = () => {
	const queryClient = useQueryClient()

	const addToWishlist = useMutation({
		mutationFn: (article: number) => WishListService.addItem(article),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['wishlist'] })
			queryClient.invalidateQueries({ queryKey: ['wishlist-status'] })
			queryClient.invalidateQueries({ queryKey: ['products'] })
		},
	})

	const removeFromWishlist = useMutation({
		mutationFn: (article: number) => WishListService.removeItem(article),
		onSuccess: (_, article) => {
			queryClient.invalidateQueries({ queryKey: ['wishlist'] })
			queryClient.invalidateQueries({ queryKey: ['wishlist-status'] })
			queryClient.invalidateQueries({ queryKey: ['products'] })
			queryClient.setQueryData<WishListPageResponse>(['wishlist'], old => {
				if (!old) return old
				return {
					...old,
					items: old.items.filter(item => item.article_number !== article),
					totalItems: old.total_items - 1,
				}
			})
		},
	})

	return { addToWishlist, removeFromWishlist }
}


import styles from './CartPage.module.scss'

export const CartPage = () => {
	return (
		<div className={styles.container}>
			<h1>Корзина</h1>
		</div>
	)
}

.container {
	padding: 24px;
	min-height: 100vh;
	padding-bottom: 80px;
}


.container {
	display: flex;
	flex-direction: column;
	min-height: 100vh;

	h1 {
		padding: 24px;
		color: rgba(0, 0, 0, 0.85);
		text-align: center;
		margin-top: 0;
	}
	.toolbar {
		padding: 16px 24px;
		background: white;
		border-bottom: 1px solid #f0f0f0;
	}
}


import styles from './ProfilePage.module.scss'

export const ProfilePage = () => {
	return (
		<div className={styles.container}>
			<h1>Профиль</h1>
		</div>
	)
}
.container {
	padding: 24px;
	min-height: 100vh;
	padding-bottom: 80px;
}

import { Button, Spin, Typography } from 'antd'
import { useState } from 'react'
import { WishListItem } from '../../components/WishListItem/WishListItemComponent'
import { useWishlist } from '../../hooks/useWishList'
import styles from './WishlistPage.module.scss'

const { Title } = Typography

export const WishlistPage = () => {
	const [page, setPage] = useState(0)
	const { data, isLoading, isFetching } = useWishlist(page)
	const [removedArticles, setRemovedArticles] = useState<number[]>([])

	const handleLoadMore = () => setPage(prev => prev + 1)
	const handleRemove = (article: number) =>
		setRemovedArticles(prev => [...prev, article])

	const filteredItems =
		data?.items.filter(
			item => !removedArticles.includes(item.article_number)
		) || []

	return (
		<div className={styles.container}>
			<Title level={2} className={styles.title}>
				Список желаний
			</Title>

			{isLoading ? (
				<Spin size='large' className={styles.spinner} />
			) : (
				<>
					<div className={styles.list}>
						{filteredItems.map(item => (
							<WishListItem
								key={item.article_number}
								article={item.article_number}
								onRemove={handleRemove}
							/>
						))}
					</div>

					{data?.current_page < data?.total_pages && (
						<div className={styles.loadMore}>
							<Button
								type='primary'
								loading={isFetching}
								onClick={handleLoadMore}
							>
								Показать еще
							</Button>
						</div>
					)}
				</>
			)}

			{!isLoading && filteredItems.length === 0 && (
				<div className={styles.empty}>В списке желаний пока нет товаров</div>
			)}
		</div>
	)
}
.container {
	padding: 24px;
	min-height: 100vh;
	padding-bottom: 80px;
}

.title {
	text-align: center;
	margin-bottom: 32px !important;
}

.list {
	max-width: 800px;
	margin: 0 auto;
}

.loadMore {
	display: flex;
	justify-content: center;
	margin: 24px 0;
}

.spinner {
	display: block;
	margin: 40px auto;
}

.empty {
	text-align: center;
	font-size: 16px;
	color: rgba(0, 0, 0, 0.45);
	padding: 40px 0;
}



import { HeartFilled } from '@ant-design/icons'
import { Button, Rate, Skeleton } from 'antd'
import { Link } from 'react-router-dom'
import { useProductDetails } from '../../hooks/useProducts'
import { useWishlistActions } from '../../hooks/useWishList'
import styles from './WishListItem.module.scss'

type WishListItemProps = {
	article: number
	onRemove: (article: number) => void
}

export const WishListItem = ({ article, onRemove }: WishListItemProps) => {
	const { data: product, isLoading } = useProductDetails(article)
	const { removeFromWishlist } = useWishlistActions()

	const handleRemove = () => {
		onRemove(article)
		removeFromWishlist.mutate(article)
	}

	if (!product && !isLoading) return null

	return (
		<div className={styles.item}>
			<Skeleton loading={isLoading} active>
				{product && (
					<>
						<Link
							to={`/product/${product.article_number}`}
							className={styles.imageLink}
						>
							<img
								src={product.photos[0] || '/placeholder-product.jpg'}
								alt={product.name}
								className={styles.image}
							/>
						</Link>

						<div className={styles.content}>
							<h3 className={styles.title}>{product.name}</h3>
							<Rate value={product.rating} disabled className={styles.rate} />
							<div className={styles.price}>{product.price} ₽</div>
						</div>

						<Button
							type='primary'
							danger
							icon={<HeartFilled />}
							onClick={handleRemove}
							className={styles.removeButton}
						/>
					</>
				)}
			</Skeleton>
		</div>
	)
}
.item {
	display: flex;
	align-items: center;
	gap: 24px;
	padding: 16px;
	background: white;
	border-radius: 8px;
	margin-bottom: 16px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	transition: transform 0.3s;

	&:hover {
		transform: translateX(4px);
	}
}

.imageLink {
	flex: 0 0 120px;
	height: 120px;
	overflow: hidden;
	border-radius: 8px;
}

.image {
	width: 100%;
	height: 100%;
	object-fit: cover;
}

.content {
	flex: 1;
	min-width: 0;
}

.title {
	font-size: 16px;
	margin-bottom: 8px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.price {
	font-size: 18px;
	font-weight: 600;
	color: #1890ff;
	margin-top: 8px;
}

.removeButton {
	flex: 0 0 40px;
	height: 40px;
	display: flex;
	align-items: center;
	justify-content: center;
}

.rate {
	font-size: 14px;
}


export interface AuthResponse {
	access_token: string
	access_expires_at: string
	issued_at: string
	refresh_token: string
	refresh_expires_at: string
}

export interface AddToCartRequest {
	article_number: number
	quantity: number
}

export interface CartItem {
	id: number
	article_number: number
	product_name: string
	price: number
	quantity: number
	add_date: string
}

export interface CartPageResponse {
	items: CartItem[]
	current_page: number
	total_pages: number
	total_items: number
}

export interface CategoryResponse {
	categories: Record<string, number>
}

export interface CategoryAttributesResponse {
	category_id: number
	category_name: string
	attributes: AttributeDTO[]
}

export interface AttributeDTO {
	id: number
	name: string
	values: string[]
}

export interface CreateOrderRequest {
	payment_method: 'CASH' | 'CARD' | 'CRYPTO'
	order_address: string
}

export interface OrderDTO {
	id: number
	status: 'CREATED' | 'PROCESSING' | 'DELIVERED' | 'CANCELLED'
	order_amount: number
	payment_method: string
	order_address: string
	expected_date: string
	created_at: string
	items: OrderItemDTO[]
}

export interface OrderItemDTO {
	article_number: number
	product_name: string
	quantity: number
	price: number
}

export interface OrderPageResponse {
	orders: OrderDTO[]
	current_page: number
	total_pages: number
	total_orders: number
}

import { ReviewDTO } from './review'

export interface ProductResponse {
	id: number
	article_number: number
	name: string
	price: number
	rating: number
	number_of_orders: number
	attributes: ProductAttributeDTO[]
	category_id: number
	category_name: string
	photos: string[]
	reviews: ReviewDTO[]
	inCart?: number
	inWishlist?: boolean
}

export interface ProductAttributeDTO {
	attribute_id: number
	attribute_name: string
	value: string
}

export interface ProductPageResponse {
	products: ProductResponse[]
	current_page: number
	total_pages: number
	total_products: number
}

export interface ReviewDTO {
	id?: number
	rating: number
	text: string
	created_at?: string
	photos?: string[]
}

export interface ReviewResponse {
	id: number
	rating: number
	text: string
}

export interface PhotoReviewRequest {
	review_id: number
	index_number: number
}

export interface WishListItem {
	id: number
	article_number: number
	product_name: string
	price: number
	add_date: string
}

export interface WishListPageResponse {
	items: WishListItem[]
	current_page: number
	total_pages: number
	total_items: number
}

import { retrieveRawInitData } from '@telegram-apps/sdk-react'
import axios from 'axios'
import { AuthService } from '../api/auth'

const api = axios.create({ baseURL: '/api' })

api.interceptors.request.use(config => {
	const initDataRaw = retrieveRawInitData()

	if (config.url === '/auth/authenticate') {
		if (initDataRaw) {
			config.headers['X-Telegram-Init-Data'] = initDataRaw
		}
		delete config.headers.Authorization
	} else {
		const accessToken = localStorage.getItem('accessToken')
		if (accessToken) {
			config.headers.Authorization = `Bearer ${accessToken}`
		}
		delete config.headers['X-Telegram-Init-Data']
	}

	return config
})

api.interceptors.response.use(
	response => response,
	async error => {
		const originalRequest = error.config
		if (error.response?.status === 403 && !originalRequest._retry) {
			originalRequest._retry = true

			try {
				const refreshToken = localStorage.getItem('refreshToken')
				const response = await AuthService.refreshToken(refreshToken!)

				localStorage.setItem('accessToken', response.access_token)
				localStorage.setItem('refreshToken', response.refresh_token)

				originalRequest.headers.Authorization = `Bearer ${response.access_token}`
				return api(originalRequest)
			} catch (refreshError) {
				localStorage.removeItem('accessToken')
				localStorage.removeItem('refreshToken')
				console.error('Refresh token failed:', refreshError)
				window.location.reload()
			}
		}
		return Promise.reject(error)
	}
)

export default api
import { init, viewport } from '@telegram-apps/sdk-react'

function initializeTelegramApp() {
	try {
		init()
		viewport.mount()
		viewport.expand()
	} catch (error) {
		console.error('Telegram init error:', error)
	}
}

export default initializeTelegramApp
import 'antd/dist/reset.css'
import { useEffect } from 'react'
import { useAuth } from './hooks/useAuth'
import { useInitialData } from './hooks/useInitialData'
import initializeTelegramApp from './utils/initTelegram'

//

import { Route, Routes } from 'react-router-dom'
import { NavbarContainer } from './containers/NavbarContainer/NavbarContainer'
import { CartPage } from './pages/CartPage/CartPage'
import { HomePage } from './pages/HomePage/HomePage'
import { ProfilePage } from './pages/ProfilePage/ProfilePage'
import { WishlistPage } from './pages/WishListPage/WishlistPage'
import { ProductPage } from './pages/ProductPage/ProductPage'

export default function App() {
	useEffect(() => {
		initializeTelegramApp()
	}, [])

	const { authData, isAuthLoading, authError } = useAuth()
	const queries = useInitialData()

	useEffect(() => {
		if (authData?.isAuthenticated) {
			const [products, orders, wishlist, cart] = queries
			console.log('Initial data loaded:', {
				products: products.data,
				orders: orders.data,
				wishlist: wishlist.data,
				cart: cart.data,
			})
		}
	}, [queries, authData])

	if (isAuthLoading) {
		return <div>Authenticating with Telegram...</div>
	}

	if (authError) {
		return (
			<div>
				Authentication failed: {authError.message}
				<button onClick={() => window.location.reload()}>Retry</button>
			</div>
		)
	}

	return (
		<>
			<Routes>
				<Route path='/' element={<HomePage />} />
				<Route path='/wishlist' element={<WishlistPage />} />
				<Route path='/profile' element={<ProfilePage />} />
				<Route path='/cart' element={<CartPage />} />
				<Route path='/product/:article' element={<ProductPage />} />
			</Routes>
			<NavbarContainer />
		</>
	)
}
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App'
import { QueryProvider } from './app/QueryProvider'

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<BrowserRouter>
			<QueryProvider>
				<App />
			</QueryProvider>
		</BrowserRouter>
	</React.StrictMode>
)

```

Изучи кодовую базу моего проекта и помоги реализовать следующие модули 
Отправлять ответ нужно в следующем формате 
- Список файлов и директорий которые нужно создать 
- Код, полностью, стили и сами компоненты и прочее если понадобится
После реализации одного модуля, я проверяю его работу и мы переходим к следующему, в следующем сообщении
Модуль 1: Решение ошибок
```typescript
WishlistPage
'data.current_page' is possibly 'undefined'.ts(18048)
const data: WishListPageResponse | undefined
The last successfully resolved data for the query.
ProductPage
{product.attributes.length > 0 && (
					<div className={styles.attributes}>
						<h3>Характеристики:</h3>
						{product.attributes.map(attr => (
							<div key={attr.attribute_id} className={styles.attribute}>
								<span>{attr.attribute_name}:</span>
								<span>{attr.value}</span>
							</div>
						))}
					</div>
				)}


				<div className={styles.reviews}>
					<h3>Отзывы ({product.reviews.length})</h3>
					{product.reviews.map(review => (
						<div key={review.id} className={styles.review}>
							<Rate value={review.rating} disabled />
							<p>{review.text}</p>
							{review.photos?.map((photo, i) => (
								<img key={i} src={photo} alt={`Фото отзыва ${i + 1}`} />
							))}
						</div>
					))}
'product' is possibly 'undefined'. - 4 раза
```
Модуль 2: Страница "Корзина", в ней должны находиться все товары из корзины пользователя, и располагаться аналогичным списком как в списке желаний, только вместо сердечка кнопки для добавления убавления из корзины количества (также добавь кнопку с иконкой мусорки, которая просто удаляет товар из корзины)
Далее вверху корзины должна быть кнопка сделать заказ, которая направляет на страничку заполнения информации о заказе (нужно сделать небольшую сводку, по итгговой стоимости а также по содержанию заказа и дать пользователю форму для заполнения и написать уведомление, что заказ успешно создан и т.д.
Важно, что товары в корзине имеют пагинацию, и что важно синхронизировать все состояния (количество в корзине и есть ли товар в корзине илли нет) аналогично как это сделано на страничке с одним товаром или общим списком чтобы все было синхронизированно и если товар удален из корзины то он исчезает из странички с корзиной
Модуль 3: Страница профиля пользователя, через sdk реакта telegram web mini app, можно извлечь информацию о пользователе (username, фото и т.д.)
Сделай чтобы эта информация также отображалась на этой странице (например фото и никнейм сверху, фото в кружочке слева) 
А ниже список 
- Мои заказы 
- Корзина
- Список желаний
- Выйти 
На кнопки корзина и список желаний просто направляют на нужные странички 
Реализация "Мои заказы" и "Выйти" будет реализацией следующих модулей
Модуль 4: Мои заказы 
Список заказов пользователя, в виде списка где каждый элемент горизонтально растянут, (пусть будут изображения товаров которые содержались в заказке, но в 1 квадратик у местить 4 миниатюрных фото, если фото нет, просто пустые серые квадратики с обводкой
При нажатии на элемент должно выпадать модальное окошко, в котором будет краткая инфомрация по заказу (статус, метод оплаты, список товаров, сумма и т.д. (причем в списке товаров нужно сделать так, чтобы можно было перейти к товару)
Для разных статусов товара делай несколько цветов и чтобы в списке заказов без открытия модального окна сразу было видно статус заказа 
Модуль 5: Отзывы 
Нужно дать пользователю возможно оставлять отзывы на товары которые он заказал и получил, например если пользователь переходит из своих заказов на страничку товара нужно дать ему возможность оставить ровно 1 отзыв, (можно проверять есть ли в списке отзывов id пользователя)
При переходе на страничку товара должна появляться кнопка "Оставить отзыв" 
Когда пользователь нажимает её появляется модальное окно, в котором нужно заполнить форму для отправки отзыва 
Где можно добавить до 3-х фотографий, поставить 1-5 звезд и написать текст, затем нажать кнопку "Готово" и отзыв отправится
Модуль 6: Выйти
При нажатии на кнопку выйти, должен отправляться запрос и пользователь может выйти из приложения и оно должно закрыться автоматически (если это возможно)

Дополнение: Если понадобится реализовать дополнительную логику на серверной части, скажи об этом и напиши какой эндпоинт использовать и какие параметры и что нужно делать 

Приступай к реализации
